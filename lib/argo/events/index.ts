// *** WARNING: this file was generated by the apigen generation tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import { core, meta } from '@jkcfg/kubernetes/api';
import { KubernetesObject } from '@dpu/jkcfg-k8s';


export namespace argoproj {
  export namespace common {
    /**
     * Backoff for an operation
     */
    export class Backoff {
      /**
       * Duration is the duration in nanoseconds
       */
      public duration: number;

      /**
       * Duration is multiplied by factor each iteration
       */
      public factor: number;


      /**
       * The amount of jitter applied each iteration
       */
      public jitter?: number;

      /**
       * Exit with error after this many steps
       */
      public steps?: number;


    }

    /**
     * Condition contains details about resource state
     */
    export class Condition {
      /**
       * Condition type.
       */
      public type: string;


      /**
       * Last time the condition transitioned from one status to another.
       */
      public lastTransitionTime?: string;

      /**
       * Human-readable message indicating details about last transition.
       */
      public message?: string;

      /**
       * Unique, this should be a short, machine understandable string that gives the reason for
       * condition's last transition. For example, "ImageNotFound"
       */
      public reason?: string;


    }

    /**
     * S3Artifact contains information about an S3 connection and bucket
     */
    export class S3Artifact {

      public accessKey: core.v1.SecretKeySelector;


      public bucket: argoproj.common.S3Bucket;


      public endpoint: string;


      public secretKey: core.v1.SecretKeySelector;



      public events?: string[];


      public filter?: argoproj.common.S3Filter;


      public insecure?: boolean;


      public region?: string;


    }

    /**
     * S3Bucket contains information to describe an S3 Bucket
     */
    export class S3Bucket {

      public name: string;



      public key?: string;


    }

    /**
     * S3Filter represents filters to apply to bucket nofifications for specifying constraints on
     * objects
     */
    export class S3Filter {

      public prefix: string;


      public suffix: string;



    }

  }

}

export namespace eventbus {
  export namespace v1alpha1 {
    /**
     * BusConfig has the finalized configuration for EventBus
     */
    export class BusConfig {


      public nats?: eventbus.v1alpha1.NATSConfig;


    }

    /**
     * EventBus is the definition of a eventbus resource
     */
    export class EventBus {

      public spec: eventbus.v1alpha1.EventBusSpec;


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ObjectMeta;


      /**
      * Create a eventbus.v1alpha1.EventBus object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: eventbus.v1alpha1.EventBus) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.kind = "EventBus";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
          this.spec = desc.spec;
      }
    }

    /**
     * EventBusList is the list of eventbus resources
     */
    export class EventBusList {

      public items: eventbus.v1alpha1.EventBus[];


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ListMeta;


      /**
      * Create a eventbus.v1alpha1.EventBusList object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: eventbus.v1alpha1.EventBusList) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.items = desc.items;
          this.kind = "EventBusList";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
      }
    }

    /**
     * EventBusSpec refers to specification of eventbus resource
     */
    export class EventBusSpec {

      /**
       * NATS eventbus
       */
      public nats?: eventbus.v1alpha1.NATSBus;


    }

    /**
     * NATSBus holds the NATS eventbus information
     */
    export class NATSBus {

      /**
       * Exotic holds an exotic NATS config
       */
      public exotic?: eventbus.v1alpha1.NATSConfig;

      /**
       * Native means to bring up a native NATS service
       */
      public native?: eventbus.v1alpha1.NativeStrategy;


    }

    /**
     * NATSConfig holds the config of NATS
     */
    export class NATSConfig {

      /**
       * Secret for auth
       */
      public accessSecret?: core.v1.SecretKeySelector;

      /**
       * Auth strategy, default to AuthStrategyNone
       */
      public auth?: string;

      /**
       * Cluster ID for nats streaming, if it's missing, treat it as NATS server
       */
      public clusterID?: string;

      /**
       * NATS host url
       */
      public url?: string;


    }

    /**
     * NativeStrategy indicates to install a native NATS service
     */
    export class NativeStrategy {


      public antiAffinity?: boolean;


      public auth?: string;


      public persistence?: eventbus.v1alpha1.PersistenceStrategy;

      /**
       * Size is the NATS StatefulSet size
       */
      public replicas?: number;


    }

    /**
     * PersistenceStrategy defines the strategy of persistence
     */
    export class PersistenceStrategy {

      /**
       * Available access modes such as ReadWriteOnce, ReadWriteMany
       * https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
       */
      public accessMode?: string;

      /**
       * Name of the StorageClass required by the claim. More info:
       * https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
       */
      public storageClassName?: string;

      /**
       * Volume size, e.g. 10Gi
       */
      public volumeSize?: string;


    }

  }

}

export namespace eventsource {
  export namespace v1alpha1 {
    /**
     * AMQPEventSource refers to an event-source for AMQP stream events
     */
    export class AMQPEventSource {
      /**
       * ExchangeName is the exchange name For more information, visit
       * https://www.rabbitmq.com/tutorials/amqp-concepts.html
       */
      public exchangeName: string;

      /**
       * ExchangeType is rabbitmq exchange type
       */
      public exchangeType: string;

      /**
       * Routing key for bindings
       */
      public routingKey: string;

      /**
       * URL for rabbitmq service
       */
      public url: string;


      /**
       * Backoff holds parameters applied to connection.
       */
      public connectionBackoff?: argoproj.common.Backoff;

      /**
       * JSONBody specifies that all event body payload coming from this source will be JSON
       */
      public jsonBody?: boolean;

      /**
       * TLS configuration for the amqp client.
       */
      public tls?: eventsource.v1alpha1.TLSConfig;


    }

    /**
     * AzureEventsHubEventSource describes the event source for azure events hub More info at
     * https://docs.microsoft.com/en-us/azure/event-hubs/
     */
    export class AzureEventsHubEventSource {
      /**
       * FQDN of the EventHubs namespace you created More info at
       * https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string
       */
      public fqdn: string;

      /**
       * Event Hub path/name
       */
      public hubName: string;


      /**
       * Namespace refers to Kubernetes namespace which is used to retrieve the shared access key
       * and name from.
       */
      public namespace?: string;

      /**
       * SharedAccessKey is the the generated value of the key
       */
      public sharedAccessKey?: core.v1.SecretKeySelector;

      /**
       * SharedAccessKeyName is the name you chose for your application's SAS keys
       */
      public sharedAccessKeyName?: core.v1.SecretKeySelector;


    }

    /**
     * CalendarEventSource describes a time based dependency. One of the fields (schedule, interval,
     * or recurrence) must be passed. Schedule takes precedence over interval; interval takes
     * precedence over recurrence
     */
    export class CalendarEventSource {
      /**
       * Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h...
       */
      public interval: string;

      /**
       * Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron
       */
      public schedule: string;



      public exclusionDates?: string[];

      /**
       * Timezone in which to run the schedule
       */
      public timezone?: string;

      /**
       * UserPayload will be sent to sensor as extra data once the event is triggered
       */
      public userPayload?: string;


    }

    /**
     * EmitterEventSource describes the event source for emitter More info at
     * https://emitter.io/develop/getting-started/
     */
    export class EmitterEventSource {
      /**
       * Broker URI to connect to.
       */
      public broker: string;

      /**
       * ChannelKey refers to the channel key
       */
      public channelKey: string;

      /**
       * ChannelName refers to the channel name
       */
      public channelName: string;


      /**
       * Backoff holds parameters applied to connection.
       */
      public connectionBackoff?: argoproj.common.Backoff;

      /**
       * JSONBody specifies that all event body payload coming from this source will be JSON
       */
      public jsonBody?: boolean;

      /**
       * Namespace to use to retrieve the channel key and optional username/password
       */
      public namespace?: string;

      /**
       * Password to use to connect to broker
       */
      public password?: core.v1.SecretKeySelector;

      /**
       * TLS configuration for the emitter client.
       */
      public tls?: eventsource.v1alpha1.TLSConfig;

      /**
       * Username to use to connect to broker
       */
      public username?: core.v1.SecretKeySelector;


    }

    /**
     * EventSource is the definition of a eventsource resource
     */
    export class EventSource {

      public spec: eventsource.v1alpha1.EventSourceSpec;


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ObjectMeta;


      /**
      * Create a eventsource.v1alpha1.EventSource object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: eventsource.v1alpha1.EventSource) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.kind = "EventSource";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
          this.spec = desc.spec;
      }
    }

    /**
     * EventSourceList is the list of eventsource resources
     */
    export class EventSourceList {

      public items: eventsource.v1alpha1.EventSource[];


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ListMeta;


      /**
      * Create a eventsource.v1alpha1.EventSourceList object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: eventsource.v1alpha1.EventSourceList) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.items = desc.items;
          this.kind = "EventSourceList";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
      }
    }

    /**
     * EventSourceSpec refers to specification of event-source resource
     */
    export class EventSourceSpec {

      /**
       * AMQP event sources
       */
      public amqp?: object;

      /**
       * AzureEventsHub event sources
       */
      public azureEventsHub?: object;

      /**
       * Calendar event sources
       */
      public calendar?: object;

      /**
       * Emitter event source
       */
      public emitter?: object;

      /**
       * File event sources
       */
      public file?: object;

      /**
       * Generic event source
       */
      public generic?: object;

      /**
       * Github event sources
       */
      public github?: object;

      /**
       * Gitlab event sources
       */
      public gitlab?: object;

      /**
       * HDFS event sources
       */
      public hdfs?: object;

      /**
       * Kafka event sources
       */
      public kafka?: object;

      /**
       * Minio event sources
       */
      public minio?: object;

      /**
       * MQTT event sources
       */
      public mqtt?: object;

      /**
       * NATS event sources
       */
      public nats?: object;

      /**
       * NSQ event source
       */
      public nsq?: object;

      /**
       * PubSub eevnt sources
       */
      public pubSub?: object;

      /**
       * Redis event source
       */
      public redis?: object;

      /**
       * Resource event sources
       */
      public resource?: object;

      /**
       * Slack event sources
       */
      public slack?: object;

      /**
       * SNS event sources
       */
      public sns?: object;

      /**
       * SQS event sources
       */
      public sqs?: object;

      /**
       * StorageGrid event sources
       */
      public storageGrid?: object;

      /**
       * Stripe event sources
       */
      public stripe?: object;

      /**
       * Webhook event sources
       */
      public webhook?: object;


    }

    /**
     * FileEventSource describes an event-source for file related events.
     */
    export class FileEventSource {
      /**
       * Type of file operations to watch Refer
       * https://github.com/fsnotify/fsnotify/blob/master/fsnotify.go for more information
       */
      public eventType: string;

      /**
       * WatchPathConfig contains configuration about the file path to watch
       */
      public watchPathConfig: eventsource.v1alpha1.WatchPathConfig;


      /**
       * Use polling instead of inotify
       */
      public polling?: boolean;


    }

    /**
     * GenericEventSource refers to a generic event source. It can be used to implement a custom
     * event source.
     */
    export class GenericEventSource {
      /**
       * Value of the event source
       */
      public value: string;



    }

    /**
     * GithubEventSource refers to event-source for github related events
     */
    export class GithubEventSource {

      public events: string[];

      /**
       * Id is the webhook's id
       */
      public id: number;

      /**
       * Owner refers to GitHub owner name i.e. argoproj
       */
      public owner: string;

      /**
       * Repository refers to GitHub repo name i.e. argo-events
       */
      public repository: string;


      /**
       * Active refers to status of the webhook for event deliveries.
       * https://developer.github.com/webhooks/creating/#active
       */
      public active?: boolean;

      /**
       * APIToken refers to a K8s secret containing github api token
       */
      public apiToken?: core.v1.SecretKeySelector;

      /**
       * ContentType of the event delivery
       */
      public contentType?: string;

      /**
       * DeleteHookOnFinish determines whether to delete the GitHub hook for the repository once the
       * event source is stopped.
       */
      public deleteHookOnFinish?: boolean;

      /**
       * GitHub base URL (for GitHub Enterprise)
       */
      public githubBaseURL?: string;

      /**
       * GitHub upload URL (for GitHub Enterprise)
       */
      public githubUploadURL?: string;

      /**
       * Insecure tls verification
       */
      public insecure?: boolean;

      /**
       * Namespace refers to Kubernetes namespace which is used to retrieve webhook secret and api
       * token from.
       */
      public namespace?: string;

      /**
       * Webhook refers to the configuration required to run a http server
       */
      public webhook?: eventsource.v1alpha1.WebhookContext;

      /**
       * WebhookSecret refers to K8s secret containing GitHub webhook secret
       * https://developer.github.com/webhooks/securing/
       */
      public webhookSecret?: core.v1.SecretKeySelector;


    }

    /**
     * GitlabEventSource refers to event-source related to Gitlab events
     */
    export class GitlabEventSource {
      /**
       * Events are gitlab event to listen to. Refer
       * https://github.com/xanzy/go-gitlab/blob/bf34eca5d13a9f4c3f501d8a97b8ac226d55e4d9/projects.go#L794.
       */
      public events: string[];

      /**
       * GitlabBaseURL is the base URL for API requests to a custom endpoint
       */
      public gitlabBaseURL: string;

      /**
       * ProjectID is the id of project for which integration needs to setup
       */
      public projectID: string;


      /**
       * AccessToken is reference to k8 secret which holds the gitlab api access information
       */
      public accessToken?: core.v1.SecretKeySelector;

      /**
       * DeleteHookOnFinish determines whether to delete the GitLab hook for the project once the
       * event source is stopped.
       */
      public deleteHookOnFinish?: boolean;

      /**
       * EnableSSLVerification to enable ssl verification
       */
      public enableSSLVerification?: boolean;

      /**
       * Webhook holds configuration to run a http server
       */
      public webhook?: eventsource.v1alpha1.WebhookContext;


    }

    /**
     * HDFSEventSource refers to event-source for HDFS related events
     */
    export class HDFSEventSource {

      public addresses: string[];

      /**
       * Directory to watch for events
       */
      public directory: string;

      /**
       * Type of file operations to watch
       */
      public type: string;


      /**
       * CheckInterval is a string that describes an interval duration to check the directory state,
       * e.g. 1s, 30m, 2h... (defaults to 1m)
       */
      public checkInterval?: string;

      /**
       * HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab
       * is used.
       */
      public hdfsUser?: string;

      /**
       * KrbCCacheSecret is the secret selector for Kerberos ccache Either ccache or keytab can be
       * set to use Kerberos.
       */
      public krbCCacheSecret?: core.v1.SecretKeySelector;

      /**
       * KrbConfig is the configmap selector for Kerberos config as string It must be set if either
       * ccache or keytab is used.
       */
      public krbConfigConfigMap?: core.v1.ConfigMapKeySelector;

      /**
       * KrbKeytabSecret is the secret selector for Kerberos keytab Either ccache or keytab can be
       * set to use Kerberos.
       */
      public krbKeytabSecret?: core.v1.SecretKeySelector;

      /**
       * KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.
       */
      public krbRealm?: string;

      /**
       * KrbServicePrincipalName is the principal name of Kerberos service It must be set if either
       * ccache or keytab is used.
       */
      public krbServicePrincipalName?: string;

      /**
       * KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is
       * used.
       */
      public krbUsername?: string;

      /**
       * Namespace refers to Kubernetes namespace which is used to retrieve cache secret and ket tab
       * secret from.
       */
      public namespace?: string;

      /**
       * Path is relative path of object to watch with respect to the directory
       */
      public path?: string;

      /**
       * PathRegexp is regexp of relative path of object to watch with respect to the directory
       */
      public pathRegexp?: string;


    }

    /**
     * KafkaEventSource refers to event-source for Kafka related events
     */
    export class KafkaEventSource {
      /**
       * Partition name
       */
      public partition: string;

      /**
       * Topic name
       */
      public topic: string;

      /**
       * URL to kafka cluster
       */
      public url: string;


      /**
       * Backoff holds parameters applied to connection.
       */
      public connectionBackoff?: argoproj.common.Backoff;

      /**
       * TLS configuration for the kafka client.
       */
      public tls?: eventsource.v1alpha1.TLSConfig;


    }

    /**
     * MQTTEventSource refers to event-source for MQTT related events
     */
    export class MQTTEventSource {
      /**
       * ClientID is the id of the client
       */
      public clientId: string;

      /**
       * Topic name
       */
      public topic: string;

      /**
       * URL to connect to broker
       */
      public url: string;


      /**
       * ConnectionBackoff holds backoff applied to connection.
       */
      public connectionBackoff?: argoproj.common.Backoff;

      /**
       * JSONBody specifies that all event body payload coming from this source will be JSON
       */
      public jsonBody?: boolean;

      /**
       * TLS configuration for the mqtt client.
       */
      public tls?: eventsource.v1alpha1.TLSConfig;


    }

    /**
     * NATSEventSource refers to event-source for NATS related events
     */
    export class NATSEventsSource {
      /**
       * Subject holds the name of the subject onto which messages are published
       */
      public subject: string;

      /**
       * URL to connect to NATS cluster
       */
      public url: string;


      /**
       * ConnectionBackoff holds backoff applied to connection.
       */
      public connectionBackoff?: argoproj.common.Backoff;

      /**
       * JSONBody specifies that all event body payload coming from this source will be JSON
       */
      public jsonBody?: boolean;

      /**
       * TLS configuration for the nats client.
       */
      public tls?: eventsource.v1alpha1.TLSConfig;


    }

    /**
     * NSQEventSource describes the event source for NSQ PubSub More info at
     * https://godoc.org/github.com/nsqio/go-nsq
     */
    export class NSQEventSource {
      /**
       * Channel used for subscription
       */
      public channel: string;

      /**
       * HostAddress is the address of the host for NSQ lookup
       */
      public hostAddress: string;

      /**
       * Topic to subscribe to.
       */
      public topic: string;


      /**
       * Backoff holds parameters applied to connection.
       */
      public connectionBackoff?: argoproj.common.Backoff;

      /**
       * JSONBody specifies that all event body payload coming from this source will be JSON
       */
      public jsonBody?: boolean;

      /**
       * TLS configuration for the nsq client.
       */
      public tls?: eventsource.v1alpha1.TLSConfig;


    }

    /**
     * PubSubEventSource refers to event-source for GCP PubSub related events.
     */
    export class PubSubEventSource {
      /**
       * CredentialsFile is the file that contains credentials to authenticate for GCP
       */
      public credentialsFile: string;

      /**
       * ProjectID is the unique identifier for your project on GCP
       */
      public projectID: string;

      /**
       * Topic on which a subscription will be created
       */
      public topic: string;

      /**
       * TopicProjectID identifies the project where the topic should exist or be created (assumed
       * to be the same as ProjectID by default)
       */
      public topicProjectID: string;


      /**
       * DeleteSubscriptionOnFinish determines whether to delete the GCP PubSub subscription once
       * the event source is stopped.
       */
      public deleteSubscriptionOnFinish?: boolean;

      /**
       * EnableWorkflowIdentity determines if your project authenticates to GCP with
       * WorkflowIdentity or CredentialsFile. If true, authentication is done with WorkflowIdentity.
       * If false or omitted, authentication is done with CredentialsFile.
       */
      public enableWorkflowIdentity?: boolean;

      /**
       * JSONBody specifies that all event body payload coming from this source will be JSON
       */
      public jsonBody?: boolean;


    }

    /**
     * RedisEventSource describes an event source for the Redis PubSub. More info at
     * https://godoc.org/github.com/go-redis/redis#example-PubSub
     */
    export class RedisEventSource {

      public channels: string[];

      /**
       * HostAddress refers to the address of the Redis host/server
       */
      public hostAddress: string;


      /**
       * DB to use. If not specified, default DB 0 will be used.
       */
      public db?: number;

      /**
       * Namespace to use to retrieve the password from. It should only be specified if password is
       * declared
       */
      public namespace?: string;

      /**
       * Password required for authentication if any.
       */
      public password?: core.v1.SecretKeySelector;

      /**
       * TLS configuration for the redis client.
       */
      public tls?: eventsource.v1alpha1.TLSConfig;


    }

    /**
     * ResourceEventSource refers to a event-source for K8s resource related events.
     */
    export class ResourceEventSource {
      /**
       * EventTypes is the list of event type to watch. Possible values are - ADD, UPDATE and
       * DELETE.
       */
      public eventTypes: string[];


      public group: string;

      /**
       * Namespace where resource is deployed
       */
      public namespace: string;


      public resource: string;


      public version: string;


      /**
       * Filter is applied on the metadata of the resource If you apply filter, then the internal
       * event informer will only monitor objects that pass the filter.
       */
      public filter?: eventsource.v1alpha1.ResourceFilter;


    }

    /**
     * ResourceFilter contains K8 ObjectMeta information to further filter resource event objects
     */
    export class ResourceFilter {

      /**
       * If the resource is created after the start time then the event is treated as valid.
       */
      public afterStart?: boolean;

      /**
       * If resource is created before the specified time then the event is treated as valid.
       */
      public createdBy?: string;

      /**
       * Fields provide listing options to K8s API to watch resource/s. Refer
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/ for more
       * info.
       */
      public fields?: eventsource.v1alpha1.Selector[];

      /**
       * Labels provide listing options to K8s API to watch resource/s. Refer
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/label-selectors/ for more
       * info.
       */
      public labels?: eventsource.v1alpha1.Selector[];

      /**
       * Prefix filter is applied on the resource name.
       */
      public prefix?: string;


    }

    /**
     * SNSEventSource refers to event-source for AWS SNS related events
     */
    export class SNSEventSource {
      /**
       * Region is AWS region
       */
      public region: string;

      /**
       * TopicArn
       */
      public topicArn: string;


      /**
       * AccessKey refers K8 secret containing aws access key
       */
      public accessKey?: core.v1.SecretKeySelector;

      /**
       * Namespace refers to Kubernetes namespace to read access related secret from.
       */
      public namespace?: string;

      /**
       * RoleARN is the Amazon Resource Name (ARN) of the role to assume.
       */
      public roleARN?: string;

      /**
       * SecretKey refers K8 secret containing aws secret key
       */
      public secretKey?: core.v1.SecretKeySelector;

      /**
       * Webhook configuration for http server
       */
      public webhook?: eventsource.v1alpha1.WebhookContext;


    }

    /**
     * SQSEventSource refers to event-source for AWS SQS related events
     */
    export class SQSEventSource {
      /**
       * Queue is AWS SQS queue to listen to for messages
       */
      public queue: string;

      /**
       * Region is AWS region
       */
      public region: string;

      /**
       * WaitTimeSeconds is The duration (in seconds) for which the call waits for a message to
       * arrive in the queue before returning.
       */
      public waitTimeSeconds: number;


      /**
       * AccessKey refers K8 secret containing aws access key
       */
      public accessKey?: core.v1.SecretKeySelector;

      /**
       * JSONBody specifies that all event body payload coming from this source will be JSON
       */
      public jsonBody?: boolean;

      /**
       * Namespace refers to Kubernetes namespace to read access related secret from.
       */
      public namespace?: string;

      /**
       * QueueAccountId is the ID of the account that created the queue to monitor
       */
      public queueAccountId?: string;

      /**
       * RoleARN is the Amazon Resource Name (ARN) of the role to assume.
       */
      public roleARN?: string;

      /**
       * SecretKey refers K8 secret containing aws secret key
       */
      public secretKey?: core.v1.SecretKeySelector;


    }

    /**
     * Selector represents conditional operation to select K8s objects.
     */
    export class Selector {
      /**
       * Key name
       */
      public key: string;

      /**
       * Value
       */
      public value: string;


      /**
       * Supported operations like ==, !=, <=, >= etc. Defaults to ==. Refer
       * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * for more info.
       */
      public operation?: string;


    }

    /**
     * SlackEventSource refers to event-source for Slack related events
     */
    export class SlackEventSource {

      /**
       * Namespace refers to Kubernetes namespace which is used to retrieve token and signing secret
       * from.
       */
      public namespace?: string;

      /**
       * Slack App signing secret
       */
      public signingSecret?: core.v1.SecretKeySelector;

      /**
       * Token for URL verification handshake
       */
      public token?: core.v1.SecretKeySelector;

      /**
       * Webhook holds configuration for a REST endpoint
       */
      public webhook?: eventsource.v1alpha1.WebhookContext;


    }

    /**
     * StorageGridEventSource refers to event-source for StorageGrid related events
     */
    export class StorageGridEventSource {
      /**
       * ApiURL is the url of the storagegrid api.
       */
      public apiURL: string;

      /**
       * Auth token for storagegrid api
       */
      public authToken: core.v1.SecretKeySelector;

      /**
       * Name of the bucket to register notifications for.
       */
      public bucket: string;

      /**
       * TopicArn
       */
      public topicArn: string;



      public events?: string[];

      /**
       * Filter on object key which caused the notification.
       */
      public filter?: eventsource.v1alpha1.StorageGridFilter;

      /**
       * S3 region. Defaults to us-east-1
       */
      public region?: string;

      /**
       * Webhook holds configuration for a REST endpoint
       */
      public webhook?: eventsource.v1alpha1.WebhookContext;


    }

    /**
     * Filter represents filters to apply to bucket notifications for specifying constraints on
     * objects
     */
    export class StorageGridFilter {

      public prefix: string;


      public suffix: string;



    }

    /**
     * StripeEventSource describes the event source for stripe webhook notifications More info at
     * https://stripe.com/docs/webhooks
     */
    export class StripeEventSource {

      /**
       * APIKey refers to K8s secret that holds Stripe API key. Used only if CreateWebhook is
       * enabled.
       */
      public apiKey?: core.v1.SecretKeySelector;

      /**
       * CreateWebhook if specified creates a new webhook programmatically.
       */
      public createWebhook?: boolean;


      public eventFilter?: string[];

      /**
       * Namespace to retrieve the APIKey secret from. Must be specified in order to read API key
       * from APIKey K8s secret.
       */
      public namespace?: string;

      /**
       * Webhook holds configuration for a REST endpoint
       */
      public webhook?: eventsource.v1alpha1.WebhookContext;


    }

    /**
     * TLSConfig refers to TLS configuration for a client.
     */
    export class TLSConfig {
      /**
       * CACertPath refers the file path that contains the CA cert.
       */
      public caCertPath: string;

      /**
       * ClientCertPath refers the file path that contains client cert.
       */
      public clientCertPath: string;

      /**
       * ClientKeyPath refers the file path that contains client key.
       */
      public clientKeyPath: string;



    }


    export class WatchPathConfig {
      /**
       * Directory to watch for events
       */
      public directory: string;


      /**
       * Path is relative path of object to watch with respect to the directory
       */
      public path?: string;

      /**
       * PathRegexp is regexp of relative path of object to watch with respect to the directory
       */
      public pathRegexp?: string;


    }

    /**
     * WebhookContext holds a general purpose REST API context
     */
    export class WebhookContext {
      /**
       * REST API endpoint
       */
      public endpoint: string;

      /**
       * Method is HTTP request method that indicates the desired action to be performed for a given
       * resource. See RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
       */
      public method: string;

      /**
       * Port on which HTTP server is listening for incoming events.
       */
      public port: string;

      /**
       * URL is the url of the server.
       */
      public url: string;


      /**
       * ServerCertPath refers the file that contains the cert.
       */
      public serverCertPath?: string;

      /**
       * ServerKeyPath refers the file that contains private key
       */
      public serverKeyPath?: string;


    }

  }

}

export namespace gateway {
  export namespace v1alpha1 {
    /**
     * EventSourceRef holds information about the EventSourceRef custom resource
     */
    export class EventSourceRef {
      /**
       * Name of the event source
       */
      public name: string;


      /**
       * Namespace of the event source Default value is the namespace where referencing gateway is
       * deployed
       */
      public namespace?: string;


    }

    /**
     * Gateway is the definition of a gateway resource
     */
    export class Gateway {

      public spec: gateway.v1alpha1.GatewaySpec;


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ObjectMeta;


      /**
      * Create a gateway.v1alpha1.Gateway object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: gateway.v1alpha1.Gateway) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.kind = "Gateway";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
          this.spec = desc.spec;
      }
    }

    /**
     * GatewayList is the list of Gateway resources
     */
    export class GatewayList {

      public items: gateway.v1alpha1.Gateway[];


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ListMeta;


      /**
      * Create a gateway.v1alpha1.GatewayList object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: gateway.v1alpha1.GatewayList) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.items = desc.items;
          this.kind = "GatewayList";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
      }
    }

    /**
     * GatewayResource holds the metadata about the gateway resources
     */
    export class GatewayResource {
      /**
       * Metadata of the deployment for the gateway
       */
      public deployment: meta.v1.ObjectMeta;


      /**
       * Metadata of the service for the gateway
       */
      public service?: meta.v1.ObjectMeta;


    }

    /**
     * GatewaySpec represents gateway specifications
     */
    export class GatewaySpec {
      /**
       * Port on which the gateway event source processor is running on.
       */
      public processorPort: string;

      /**
       * Type is the type of gateway. Used as metadata.
       */
      public type: string;


      /**
       * EventSourceRef refers to event-source that stores event source configurations for the
       * gateway
       */
      public eventSourceRef?: gateway.v1alpha1.EventSourceRef;

      /**
       * Replica is the gateway deployment replicas
       */
      public replica?: number;

      /**
       * Service is the specifications of the service to expose the gateway
       */
      public service?: gateway.v1alpha1.Service;

      /**
       * Subscribers holds the contexts of the subscribers/sinks to send events to.
       */
      public subscribers?: gateway.v1alpha1.Subscribers;

      /**
       * Template is the pod specification for the gateway
       */
      public template?: gateway.v1alpha1.Template;


    }

    /**
     * Metadata holds the annotations and labels of a gateway pod
     */
    export class Metadata {


      public annotations?: {[key: string]: string};


      public labels?: {[key: string]: string};


    }

    /**
     * NATSSubscriber holds the context of subscriber over NATS.
     */
    export class NATSSubscriber {
      /**
       * Name of the subscription. Must be unique.
       */
      public name: string;

      /**
       * ServerURL refers to the NATS server URL.
       */
      public serverURL: string;

      /**
       * Subject refers to the NATS subject name.
       */
      public subject: string;



    }

    /**
     * Service holds the service information gateway exposes
     */
    export class Service {

      /**
       * clusterIP is the IP address of the service and is usually assigned randomly by the master.
       * If an address is specified manually and is not in use by others, it will be allocated to
       * the service; otherwise, creation of the service will fail. This field can not be changed
       * through updates. Valid values are "None", empty string (""), or a valid IP address. "None"
       * can be specified for headless services when proxying is not required. More info:
       * https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
       */
      public clusterIP?: string;

      /**
       * The list of ports that are exposed by this ClusterIP service.
       */
      public ports?: core.v1.ServicePort[];

      /**
       * Spec holds the gateway service spec. DEPRECATED: Use Ports to declare the ports to be
       * exposed.
       */
      public spec?: core.v1.ServiceSpec;


    }


    export class Subscribers {

      /**
       * HTTP subscribers are HTTP endpoints to send events to.
       */
      public http?: string[];

      /**
       * NATS refers to the subscribers over NATS protocol.
       */
      public nats?: gateway.v1alpha1.NATSSubscriber[];


    }

    /**
     * Template holds the information of a Gateway deployment template
     */
    export class Template {

      /**
       * If specified, the pod's scheduling constraints
       */
      public affinity?: core.v1.Affinity;

      /**
       * Container is the main container image to run in the gateway pod
       */
      public container?: core.v1.Container;

      /**
       * Metdata sets the pods's metadata, i.e. annotations and labels
       */
      public metadata?: gateway.v1alpha1.Metadata;

      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * Optional: Defaults to empty.  See type description for default values of each field.
       */
      public securityContext?: core.v1.PodSecurityContext;

      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run gateway pod. More info:
       * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      public serviceAccountName?: string;

      /**
       * Spec holds the gateway deployment spec. DEPRECATED: Use Container instead.
       */
      public spec?: core.v1.PodSpec;

      /**
       * If specified, the pod's tolerations.
       */
      public tolerations?: core.v1.Toleration[];

      /**
       * Volumes is a list of volumes that can be mounted by containers in a workflow.
       */
      public volumes?: core.v1.Volume[];


      /**
      * Create a gateway.v1alpha1.Template object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: gateway.v1alpha1.Template) {
          this.affinity = desc.affinity;
          this.container = desc.container;
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
          this.securityContext = desc.securityContext;
          this.serviceAccountName = desc.serviceAccountName;
          this.spec = desc.spec;
          this.tolerations = desc.tolerations;
          this.volumes = desc.volumes;
      }
    }

  }

}

export namespace sensor {
  export namespace v1alpha1 {
    /**
     * AWSLambdaTrigger refers to specification of the trigger to invoke an AWS Lambda function
     */
    export class AWSLambdaTrigger {
      /**
       * FunctionName refers to the name of the function to invoke.
       */
      public functionName: string;


      public payload: sensor.v1alpha1.TriggerParameter[];

      /**
       * Region is AWS region
       */
      public region: string;


      /**
       * AccessKey refers K8 secret containing aws access key
       */
      public accessKey?: core.v1.SecretKeySelector;

      /**
       * Namespace refers to Kubernetes namespace to read access related secret from. Defaults to
       * sensor's namespace.
       */
      public namespace?: string;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * SecretKey refers K8 secret containing aws secret key
       */
      public secretKey?: core.v1.SecretKeySelector;


    }

    /**
     * ArgoWorkflowTrigger is the trigger for the Argo Workflow
     */
    export class ArgoWorkflowTrigger {

      public group: string;


      public resource: string;


      public version: string;


      /**
       * Operation refers to the type of operation performed on the argo workflow resource. Default
       * value is Submit.
       */
      public operation?: string;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * Source of the K8 resource file(s)
       */
      public source?: sensor.v1alpha1.ArtifactLocation;


    }

    /**
     * ArtifactLocation describes the source location for an external artifact
     */
    export class ArtifactLocation {

      /**
       * Configmap that stores the artifact
       */
      public configmap?: sensor.v1alpha1.ConfigmapArtifact;

      /**
       * File artifact is artifact stored in a file
       */
      public file?: sensor.v1alpha1.FileArtifact;

      /**
       * Git repository hosting the artifact
       */
      public git?: sensor.v1alpha1.GitArtifact;

      /**
       * Inline artifact is embedded in sensor spec as a string
       */
      public inline?: string;

      /**
       * Resource is generic template for K8s resource
       */
      public resource?: KubernetesObject;

      /**
       * S3 compliant artifact
       */
      public s3?: argoproj.common.S3Artifact;

      /**
       * URL to fetch the artifact from
       */
      public url?: sensor.v1alpha1.URLArtifact;


    }

    /**
     * BasicAuth contains the reference to K8s secrets that holds the username and password
     */
    export class BasicAuth {

      /**
       * Namespace to read the secrets from. Defaults to sensor's namespace.
       */
      public namespace?: string;

      /**
       * Password refers to the Kubernetes secret that holds the password required for basic auth.
       */
      public password?: core.v1.SecretKeySelector;

      /**
       * Username refers to the Kubernetes secret that holds the username required for basic auth.
       */
      public username?: core.v1.SecretKeySelector;


    }

    /**
     * ConfigmapArtifact contains information about artifact in k8 configmap
     */
    export class ConfigmapArtifact {
      /**
       * Key within configmap data which contains trigger resource definition
       */
      public key: string;

      /**
       * Name of the configmap
       */
      public name: string;

      /**
       * Namespace where configmap is deployed
       */
      public namespace: string;



    }

    /**
     * CustomTrigger refers to the specification of the custom trigger.
     */
    export class CustomTrigger {

      public payload: sensor.v1alpha1.TriggerParameter[];

      /**
       * Secure refers to type of the connection between sensor to custom trigger gRPC
       */
      public secure: boolean;

      /**
       * ServerURL is the url of the gRPC server that executes custom trigger
       */
      public serverURL: string;

      /**
       * Spec is the custom trigger resource specification that custom trigger gRPC server knows how
       * to interpret.
       */
      public spec: {[key: string]: string};


      /**
       * CertFilePath is path to the cert file within sensor for secure connection between sensor
       * and custom trigger gRPC server.
       */
      public certFilePath?: string;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * ServerNameOverride for the secure connection between sensor and custom trigger gRPC server.
       */
      public serverNameOverride?: string;


    }

    /**
     * DataFilter describes constraints and filters for event data Regular Expressions are
     * purposefully not a feature as they are overkill for our uses here See Rob Pike's Post:
     * https://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html
     */
    export class DataFilter {
      /**
       * Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys
       * separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array
       * value use the index as the key. The dot and wildcard characters can be escaped with '\'.
       * See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.
       */
      public path: string;

      /**
       * Type contains the JSON type of the data
       */
      public type: string;

      /**
       * Value is the allowed string values for this key Booleans are passed using
       * strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings
       * are taken as is Nils this value is ignored
       */
      public value: string[];


      /**
       * Comparator compares the event data with a user given value. Can be ">=", ">", "=", "<", or
       * "<=". Is optional, and if left blank treated as equality "=".
       */
      public comparator?: string;


    }

    /**
     * DependencyGroup is the group of dependencies
     */
    export class DependencyGroup {
      /**
       * Dependencies of events
       */
      public dependencies: string[];

      /**
       * Name of the group
       */
      public name: string;



    }

    /**
     * Event represents the cloudevent received from a gateway.
     */
    export class Event {

      public data: string;



      public context?: sensor.v1alpha1.EventContext;


    }

    /**
     * EventContext holds the context of the cloudevent received from a gateway.
     */
    export class EventContext {
      /**
       * DataContentType - A MIME (RFC2046) string describing the media type of `data`.
       */
      public dataContentType: string;

      /**
       * ID of the event; must be non-empty and unique within the scope of the producer.
       */
      public id: string;

      /**
       * Source - A URI describing the event producer.
       */
      public source: string;

      /**
       * SpecVersion - The version of the CloudEvents specification used by the event.
       */
      public specversion: string;

      /**
       * Subject - The subject of the event in the context of the event producer
       */
      public subject: string;

      /**
       * Time - A Timestamp when the event happened.
       */
      public time: string;

      /**
       * Type - The type of the occurrence which has happened.
       */
      public type: string;



    }

    /**
     * EventDependency describes a dependency
     */
    export class EventDependency {
      /**
       * EventName is the name of the event
       */
      public eventName: string;

      /**
       * GatewayName is the name of the gateway from whom the event is received
       */
      public gatewayName: string;

      /**
       * Name is a unique name of this dependency
       */
      public name: string;


      /**
       * Filters and rules governing toleration of success and constraints on the context and data
       * of an event
       */
      public filters?: sensor.v1alpha1.EventDependencyFilter;


    }

    /**
     * EventDependencyFilter defines filters and constraints for a event.
     */
    export class EventDependencyFilter {
      /**
       * Name is the name of event filter
       */
      public name: string;


      /**
       * Context filter constraints
       */
      public context?: sensor.v1alpha1.EventContext;

      /**
       * Data filter constraints with escalation
       */
      public data?: sensor.v1alpha1.DataFilter[];

      /**
       * Time filter on the event with escalation
       */
      public time?: sensor.v1alpha1.TimeFilter;


    }

    /**
     * FileArtifact contains information about an artifact in a filesystem
     */
    export class FileArtifact {


      public path?: string;


    }

    /**
     * GitArtifact contains information about an artifact stored in git
     */
    export class GitArtifact {
      /**
       * Directory to clone the repository. We clone complete directory because GitArtifact is not
       * limited to any specific Git service providers. Hence we don't use any specific git provider
       * client.
       */
      public cloneDirectory: string;

      /**
       * Path to file that contains trigger resource definition
       */
      public filePath: string;

      /**
       * Git URL
       */
      public url: string;


      /**
       * Branch to use to pull trigger resource
       */
      public branch?: string;

      /**
       * Creds contain reference to git username and password
       */
      public creds?: sensor.v1alpha1.GitCreds;

      /**
       * Namespace where creds are stored.
       */
      public namespace?: string;

      /**
       * Ref to use to pull trigger resource. Will result in a shallow clone and fetch.
       */
      public ref?: string;

      /**
       * Remote to manage set of tracked repositories. Defaults to "origin". Refer
       * https://git-scm.com/docs/git-remote
       */
      public remote?: sensor.v1alpha1.GitRemoteConfig;

      /**
       * SSHKeyPath is path to your ssh key path. Use this if you don't want to provide username and
       * password. ssh key path must be mounted in sensor pod.
       */
      public sshKeyPath?: string;

      /**
       * Tag to use to pull trigger resource
       */
      public tag?: string;


    }

    /**
     * GitCreds contain reference to git username and password
     */
    export class GitCreds {


      public password?: core.v1.SecretKeySelector;


      public username?: core.v1.SecretKeySelector;


    }

    /**
     * GitRemoteConfig contains the configuration of a Git remote
     */
    export class GitRemoteConfig {
      /**
       * Name of the remote to fetch from.
       */
      public name: string;

      /**
       * URLs the URLs of a remote repository. It must be non-empty. Fetch will always use the first
       * URL, while push will use all of them.
       */
      public urls: string[];



    }

    /**
     * HTTPSubscription holds the context of the HTTP subscription of events for the sensor.
     */
    export class HTTPSubscription {
      /**
       * Port on which sensor server should run.
       */
      public port: number;



    }

    /**
     * HTTPTrigger is the trigger for the HTTP request
     */
    export class HTTPTrigger {

      public payload: sensor.v1alpha1.TriggerParameter[];

      /**
       * URL refers to the URL to send HTTP request to.
       */
      public url: string;


      /**
       * BasicAuth configuration for the http request.
       */
      public basicAuth?: sensor.v1alpha1.BasicAuth;

      /**
       * Headers for the HTTP request.
       */
      public headers?: {[key: string]: string};

      /**
       * Method refers to the type of the HTTP request. Refer
       * https://golang.org/src/net/http/method.go for more info. Default value is POST.
       */
      public method?: string;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * Timeout refers to the HTTP request timeout in seconds. Default value is 60 seconds.
       */
      public timeout?: number;

      /**
       * TLS configuration for the HTTP client.
       */
      public tls?: sensor.v1alpha1.TLSConfig;


    }

    /**
     * K8SResourcePolicy refers to the policy used to check the state of K8s based triggers using
     * using labels
     */
    export class K8SResourcePolicy {
      /**
       * Backoff before checking resource state
       */
      public backoff: argoproj.common.Backoff;

      /**
       * ErrorOnBackoffTimeout determines whether sensor should transition to error state if the
       * trigger policy is unable to determine the state of the resource
       */
      public errorOnBackoffTimeout: boolean;


      /**
       * Labels required to identify whether a resource is in success state
       */
      public labels?: {[key: string]: string};


    }

    /**
     * KafkaTrigger refers to the specification of the Kafka trigger.
     */
    export class KafkaTrigger {
      /**
       * Partition to write data to.
       */
      public partition: number;


      public payload: sensor.v1alpha1.TriggerParameter[];

      /**
       * Name of the topic. More info at https://kafka.apache.org/documentation/#intro_topics
       */
      public topic: string;

      /**
       * URL of the Kafka broker.
       */
      public url: string;


      /**
       * Compress determines whether to compress message or not. Defaults to false. If set to true,
       * compresses message using snappy compression.
       */
      public compress?: boolean;

      /**
       * FlushFrequency refers to the frequency in milliseconds to flush batches. Defaults to 500
       * milliseconds.
       */
      public flushFrequency?: number;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * The partitioning key for the messages put on the Kafka topic. Defaults to broker url.
       */
      public partitioningKey?: string;

      /**
       * RequiredAcks used in producer to tell the broker how many replica acknowledgements Defaults
       * to 1 (Only wait for the leader to ack).
       */
      public requiredAcks?: number;

      /**
       * TLS configuration for the Kafka producer.
       */
      public tls?: sensor.v1alpha1.TLSConfig;


    }

    /**
     * NATSSubscription holds the context of the NATS subscription of events for the sensor
     */
    export class NATSSubscription {
      /**
       * ServerURL refers to NATS server url.
       */
      public serverURL: string;

      /**
       * Subject refers to NATS subject name.
       */
      public subject: string;



    }

    /**
     * NATSTrigger refers to the specification of the NATS trigger.
     */
    export class NATSTrigger {

      public payload: sensor.v1alpha1.TriggerParameter[];

      /**
       * Name of the subject to put message on.
       */
      public subject: string;

      /**
       * URL of the NATS cluster.
       */
      public url: string;



      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * TLS configuration for the NATS producer.
       */
      public tls?: sensor.v1alpha1.TLSConfig;


    }

    /**
     * OpenWhiskTrigger refers to the specification of the OpenWhisk trigger.
     */
    export class OpenWhiskTrigger {
      /**
       * Name of the action/function.
       */
      public actionName: string;

      /**
       * Host URL of the OpenWhisk.
       */
      public host: string;


      public payload: sensor.v1alpha1.TriggerParameter[];


      /**
       * AuthToken for authentication.
       */
      public authToken?: core.v1.SecretKeySelector;

      /**
       * Namespace for the action. Defaults to "_".
       */
      public namespace?: string;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * Version for the API. Defaults to v1.
       */
      public version?: string;


    }

    /**
     * Sensor is the definition of a sensor resource
     */
    export class Sensor {

      public spec: sensor.v1alpha1.SensorSpec;


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ObjectMeta;


      /**
      * Create a sensor.v1alpha1.Sensor object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: sensor.v1alpha1.Sensor) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.kind = "Sensor";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
          this.spec = desc.spec;
      }
    }

    /**
     * SensorList is the list of Sensor resources
     */
    export class SensorList {

      public items: sensor.v1alpha1.Sensor[];


      /**
       * APIVersion defines the versioned schema of this representation of an object. Servers should
       * convert recognized schemas to the latest internal value, and may reject unrecognized
       * values. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       */
      public apiVersion?: string;

      /**
       * Kind is a string value representing the REST resource this object represents. Servers may
       * infer this from the endpoint the client submits requests to. Cannot be updated. In
       * CamelCase. More info:
       * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      public kind?: string;


      public metadata?: meta.v1.ListMeta;


      /**
      * Create a sensor.v1alpha1.SensorList object with the given unique name and description.
      *
      * @param name The _unique_ name of the object.
      * @param desc The description to use to populate this object properties.
      */
      constructor(name: string, desc: sensor.v1alpha1.SensorList) {
          this.apiVersion = "argoproj.io/v1alpha1";
          this.items = desc.items;
          this.kind = "SensorList";
          this.metadata = Object.assign({}, desc && desc.metadata || {}, { name });
      }
    }

    /**
     * SensorResources holds the metadata of the resources created for the sensor
     */
    export class SensorResources {

      /**
       * Deployment holds the metadata of the deployment for the sensor
       */
      public deployment?: meta.v1.ObjectMeta;

      /**
       * Service holds the metadata of the service for the sensor
       */
      public service?: meta.v1.ObjectMeta;


    }

    /**
     * SensorSpec represents desired sensor state
     */
    export class SensorSpec {
      /**
       * Dependencies is a list of the events that this sensor is dependent on.
       */
      public dependencies: sensor.v1alpha1.EventDependency[];

      /**
       * Triggers is a list of the things that this sensor evokes. These are the outputs from this
       * sensor.
       */
      public triggers: sensor.v1alpha1.Trigger[];


      /**
       * Circuit is a boolean expression of dependency groups
       */
      public circuit?: string;

      /**
       * DependencyGroups is a list of the groups of events.
       */
      public dependencyGroups?: sensor.v1alpha1.DependencyGroup[];

      /**
       * ErrorOnFailedRound if set to true, marks sensor state as `error` if the previous trigger
       * round fails. Once sensor state is set to `error`, no further triggers will be processed.
       */
      public errorOnFailedRound?: boolean;

      /**
       * ServiceAnnotations refers to annotations to be set for the service generated
       */
      public serviceAnnotations?: {[key: string]: string};

      /**
       * ServiceLabels to be set for the service generated
       */
      public serviceLabels?: {[key: string]: string};

      /**
       * Subscription refers to the modes of events subscriptions for the sensor. At least one of
       * the types of subscription must be defined in order for sensor to be meaningful.
       */
      public subscription?: sensor.v1alpha1.Subscription;

      /**
       * Template is the pod specification for the sensor
       */
      public template?: sensor.v1alpha1.Template;


    }

    /**
     * SlackTrigger refers to the specification of the slack notification trigger.
     */
    export class SlackTrigger {

      /**
       * Channel refers to which Slack channel to send slack message.
       */
      public channel?: string;

      /**
       * Message refers to the message to send to the Slack channel.
       */
      public message?: string;

      /**
       * Namespace to read the password secret from. This is required if the password secret
       * selector is specified.
       */
      public namespace?: string;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * SlackToken refers to the Kubernetes secret that holds the slack token required to send
       * messages.
       */
      public slackToken?: core.v1.SecretKeySelector;


    }

    /**
     * StandardK8STrigger is the standard Kubernetes resource trigger
     */
    export class StandardK8STrigger {

      public group: string;


      public resource: string;


      public version: string;


      /**
       * LiveObject specifies whether the resource should be directly fetched from K8s instead of
       * being marshaled from the resource artifact. If set to true, the resource artifact must
       * contain the information required to uniquely identify the resource in the cluster, that is,
       * you must specify "apiVersion", "kind" as well as "name" and "namespace" meta data. Only
       * valid for operation type `update`
       */
      public liveObject?: boolean;

      /**
       * Operation refers to the type of operation performed on the k8s resource. Default value is
       * Create.
       */
      public operation?: string;


      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * PatchStrategy controls the K8s object patching strategy when the trigger operation is
       * specified as patch. possible values: "application/json-patch+json"
       * "application/merge-patch+json" "application/strategic-merge-patch+json"
       * "application/apply-patch+yaml". Defaults to "application/merge-patch+json"
       */
      public patchStrategy?: string;

      /**
       * Source of the K8 resource file(s)
       */
      public source?: sensor.v1alpha1.ArtifactLocation;


    }

    /**
     * Subscription holds different modes of subscription available for sensor to consume events.
     */
    export class Subscription {

      /**
       * HTTP refers to the HTTP subscription of events for the sensor.
       */
      public http?: sensor.v1alpha1.HTTPSubscription;

      /**
       * NATS refers to the NATS subscription of events for the sensor
       */
      public nats?: sensor.v1alpha1.NATSSubscription;


    }

    /**
     * TLSConfig refers to TLS configuration for the HTTP client
     */
    export class TLSConfig {
      /**
       * CACertPath refers the file path that contains the CA cert.
       */
      public caCertPath: string;

      /**
       * ClientCertPath refers the file path that contains client cert.
       */
      public clientCertPath: string;

      /**
       * ClientKeyPath refers the file path that contains client key.
       */
      public clientKeyPath: string;



    }

    /**
     * Template holds the information of a sensor deployment template
     */
    export class Template {

      /**
       * Container is the main container image to run in the gateway pod
       */
      public container?: core.v1.Container;

      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * Optional: Defaults to empty.  See type description for default values of each field.
       */
      public securityContext?: core.v1.PodSecurityContext;

      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run gateway pod. More info:
       * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      public serviceAccountName?: string;

      /**
       * Spec holds the sensor deployment spec. DEPRECATED: Use Container instead.
       */
      public spec?: core.v1.PodSpec;

      /**
       * Volumes is a list of volumes that can be mounted by containers in a workflow.
       */
      public volumes?: core.v1.Volume[];


    }

    /**
     * TimeFilter describes a window in time. DataFilters out event events that occur outside the
     * time limits. In other words, only events that occur after Start and before Stop will pass
     * this filter.
     */
    export class TimeFilter {

      /**
       * Start is the beginning of a time window. Before this time, events for this event are
       * ignored and format is hh:mm:ss
       */
      public start?: string;

      /**
       * StopPattern is the end of a time window. After this time, events for this event are ignored
       * and format is hh:mm:ss
       */
      public stop?: string;


    }

    /**
     * Trigger is an action taken, output produced, an event created, a message sent
     */
    export class Trigger {

      /**
       * Parameters is the list of parameters applied to the trigger template definition
       */
      public parameters?: sensor.v1alpha1.TriggerParameter[];

      /**
       * Policy to configure backoff and execution criteria for the trigger
       */
      public policy?: sensor.v1alpha1.TriggerPolicy;

      /**
       * Template describes the trigger specification.
       */
      public template?: sensor.v1alpha1.TriggerTemplate;


    }

    /**
     * TriggerParameter indicates a passed parameter to a service template
     */
    export class TriggerParameter {
      /**
       * Dest is the JSONPath of a resource key. A path is a series of keys separated by a dot. The
       * colon character can be escaped with '.' The -1 key can be used to append a value to an
       * existing array. See https://github.com/tidwall/sjson#path-syntax for more information about
       * how this is used.
       */
      public dest: string;


      /**
       * Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite',
       * or 'append' it.
       */
      public operation?: string;

      /**
       * Src contains a source reference to the value of the parameter from a dependency
       */
      public src?: sensor.v1alpha1.TriggerParameterSource;


    }

    /**
     * TriggerParameterSource defines the source for a parameter from a event event
     */
    export class TriggerParameterSource {
      /**
       * DependencyName refers to the name of the dependency. The event which is stored for this
       * dependency is used as payload for the parameterization. Make sure to refer to one of the
       * dependencies you have defined under Dependencies list.
       */
      public dependencyName: string;


      /**
       * ContextKey is the JSONPath of the event's (JSON decoded) context key ContextKey is a series
       * of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an
       * array value use the index as the key. The dot and wildcard characters can be escaped with
       * '\'. See https://github.com/tidwall/gjson#path-syntax for more information on how to use
       * this.
       */
      public contextKey?: string;

      /**
       * ContextTemplate is a go-template for extracting a string from the event's context. If a
       * ContextTemplate is provided with a ContextKey, the template will be evaluated first and
       * fallback to the ContextKey. The templating follows the standard go-template syntax as well
       * as sprig's extra functions. See https://pkg.go.dev/text/template and
       * https://masterminds.github.io/sprig/
       */
      public contextTemplate?: string;

      /**
       * DataKey is the JSONPath of the event's (JSON decoded) data key DataKey is a series of keys
       * separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array
       * value use the index as the key. The dot and wildcard characters can be escaped with '\'.
       * See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.
       */
      public dataKey?: string;

      /**
       * DataTemplate is a go-template for extracting a string from the event's data. If a
       * DataTemplate is provided with a DataKey, the template will be evaluated first and fallback
       * to the DataKey. The templating follows the standard go-template syntax as well as sprig's
       * extra functions. See https://pkg.go.dev/text/template and
       * https://masterminds.github.io/sprig/
       */
      public dataTemplate?: string;

      /**
       * Value is the default literal value to use for this parameter source This is only used if
       * the DataKey is invalid. If the DataKey is invalid and this is not defined, this param
       * source will produce an error.
       */
      public value?: string;


    }

    /**
     * TriggerPolicy dictates the policy for the trigger retries
     */
    export class TriggerPolicy {

      /**
       * K8SResourcePolicy refers to the policy used to check the state of K8s based triggers using
       * using labels
       */
      public k8s?: sensor.v1alpha1.K8SResourcePolicy;


    }

    /**
     * TriggerSwitch describes condition which must be satisfied in order to execute a trigger.
     * Depending upon condition type, status of dependency groups is used to evaluate the result.
     */
    export class TriggerSwitch {

      /**
       * All acts as a AND operator between dependencies
       */
      public all?: string[];

      /**
       * Any acts as a OR operator between dependencies
       */
      public any?: string[];


    }

    /**
     * TriggerTemplate is the template that describes trigger specification.
     */
    export class TriggerTemplate {
      /**
       * Name is a unique name of the action to take.
       */
      public name: string;


      /**
       * ArgoWorkflow refers to the trigger that can perform various operations on an Argo workflow.
       */
      public argoWorkflow?: sensor.v1alpha1.ArgoWorkflowTrigger;

      /**
       * AWSLambda refers to the trigger designed to invoke AWS Lambda function with with on-the-fly
       * constructable payload.
       */
      public awsLambda?: sensor.v1alpha1.AWSLambdaTrigger;

      /**
       * CustomTrigger refers to the trigger designed to connect to a gRPC trigger server and
       * execute a custom trigger.
       */
      public custom?: sensor.v1alpha1.CustomTrigger;

      /**
       * HTTP refers to the trigger designed to dispatch a HTTP request with on-the-fly
       * constructable payload.
       */
      public http?: sensor.v1alpha1.HTTPTrigger;

      /**
       * StandardK8STrigger refers to the trigger designed to create or update a generic Kubernetes
       * resource.
       */
      public k8s?: sensor.v1alpha1.StandardK8STrigger;

      /**
       * Kafka refers to the trigger designed to place messages on Kafka topic.
       */
      public kafka?: sensor.v1alpha1.KafkaTrigger;

      /**
       * NATS refers to the trigger designed to place message on NATS subject.
       */
      public nats?: sensor.v1alpha1.NATSTrigger;

      /**
       * OpenWhisk refers to the trigger designed to invoke OpenWhisk action.
       */
      public openWhisk?: sensor.v1alpha1.OpenWhiskTrigger;

      /**
       * Slack refers to the trigger designed to send slack notification message.
       */
      public slack?: sensor.v1alpha1.SlackTrigger;

      /**
       * Switch is the condition to execute the trigger.
       */
      public switch?: sensor.v1alpha1.TriggerSwitch;


    }

    /**
     * URLArtifact contains information about an artifact at an http endpoint.
     */
    export class URLArtifact {
      /**
       * Path is the complete URL
       */
      public path: string;


      /**
       * VerifyCert decides whether the connection is secure or not
       */
      public verifyCert?: boolean;


    }

  }

}

